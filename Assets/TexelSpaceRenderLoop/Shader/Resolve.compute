// Each #kernel tells which function to compile; you can have many kernels
#include "TexelShading.cginc" 
#pragma enable_d3d11_debug_symbols

// common variables
uint g_totalObjectsInView;

// reads the VisibilityBuffer and extracts the visible triangles
// -----------------------------------------------------------------------------
#pragma kernel ExtractCoverage
Texture2D<int> g_VisibilityBuffer;
RWBuffer<uint> g_PrimitiveVisibility;
RWStructuredBuffer<ObjectToAtlasProperties> g_ObjectToAtlasProperties;

[numthreads(COMPUTE_COVERAGE_TILE_SIZE, COMPUTE_COVERAGE_TILE_SIZE,1)]
void ExtractCoverage (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	uint objectID, primitiveID, mipmapLevel;
	DecodeVisibilityBuffer(
		g_VisibilityBuffer[id.xy],
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel); 

	uint baseIndex, subIndex;
	GetVisiblityIDIndicies(objectID, primitiveID, /*out*/ baseIndex, /*out*/ subIndex);
	g_PrimitiveVisibility[baseIndex] = 1;

	//g_PrimitiveVisibility[EncodeVisibilityBuffer(objectID, primitiveID, 0)] = 1; //unlock primitve
}

// provides debug information
// -----------------------------------------------------------------------------
#pragma kernel DebugShowVertexID
RWTexture2D<float4> g_DebugTexture;
StructuredBuffer<ObjectToAtlasProperties> g_ObjectToAtlasPropertiesR;
int g_DebugPassID;

[numthreads(BLOCK_THREAD_SIZE, BLOCK_THREAD_SIZE,1)]
void DebugShowVertexID (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	uint objectID, primitiveID, mipmapLevel;
	DecodeVisibilityBuffer(
		g_VisibilityBuffer[id.xy],
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel); 


	uint baseIndex, subIndex;
	GetVisiblityIDIndicies(objectID, primitiveID, /*out*/ baseIndex, /*out*/ subIndex);

	half4 output = 0;
	float f;
	switch (g_DebugPassID)
	{
		case 1:
			f = objectID;// floor(primitiveID / PRIMITIVE_CLUSTER_SIZE);
			output = half4(sin(f), sin(f / 2), sin(f / 4), 0) * 0.5 + 0.5;
			break;
		case 2:
			f = floor(primitiveID / PRIMITIVE_CLUSTER_SIZE);
			output = half4(sin(f / 5.0), sin(f / 50.0), sin(f / 500.0), 0) * 0.5 + 0.5;
			break;
		case 3:
			float mipmap_f = g_ObjectToAtlasPropertiesR[objectID].desiredAtlasSpace_axis / 13.0;
			output = mipmap_f;
			break;
		case 4:
			output = mipmapLevel / 13.0;
			break;
	}

	g_DebugTexture[id.xy] = output;
	
}

// packs texel atlas
// -----------------------------------------------------------------------------

// julian: I use the morton-code / z-shape for atlas packing
// this makes the packing very much straight forward and the complexity for insertion is always O(1).
// But this only works, as long as the textures sizes are power-of-two (256, 512, 1024,...) and the largest textures are getting inserted first
uint2 GetTilePosition(uint index)
{
    return uint2(DecodeMorton2X(index), DecodeMorton2Y(index));
}

float4 GetTextureRect(uint index, uint tilesPerAxis)
{
	float2 atlasPosition_tileSpace = GetTilePosition(index);
    float2 min = atlasPosition_tileSpace * ATLAS_TILE_SIZE;
    float2 max = min + tilesPerAxis * ATLAS_TILE_SIZE;

	return float4(min, max);
}

float4 GetUVToAtlasScaleOffset(float4 atlasPixelSpace)
{
    return float4(atlasPixelSpace.zw - atlasPixelSpace.xy, atlasPixelSpace.xy);
}

#pragma kernel AtlasPacking
uint atlas_sliceCount;
uint g_atlasAxisSize;
[numthreads(1,1,1)] 
void AtlasPacking(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	// sort atlas objects by size (largest-smallest) so it fits the condition for a morton code packing

	//TODO: use multithread radix sort
	//simple bubble sort...
	for (uint write = 0; write < g_totalObjectsInView; write++)
	{
		for (uint sort = 0; sort < g_totalObjectsInView - 1 ; sort++)
		{
			// check if next object is larger than current
			if (g_ObjectToAtlasProperties[sort].desiredAtlasSpace_axis < 
				g_ObjectToAtlasProperties[sort + 1].desiredAtlasSpace_axis)
			{		
				// swap next object with curent
				ObjectToAtlasProperties temp = g_ObjectToAtlasProperties[sort + 1];				
				g_ObjectToAtlasProperties[sort + 1] = g_ObjectToAtlasProperties[sort];
				g_ObjectToAtlasProperties[sort] = temp;
			}
		}
	}

	AllMemoryBarrierWithGroupSync();
	//TODO: muttihreading can't be used here ad-hoc, since the order of exectuion is crucial...
	for(uint i = 0; i < g_totalObjectsInView; i++)
	{
		// TODO: can't use clamp() somehow...
		uint objectTileAxisExponent = min(ATLAS_OBJECT_SIZEEXPONENT_MAX, g_ObjectToAtlasProperties[i].desiredAtlasSpace_axis);
		objectTileAxisExponent = max(ATLAS_OBJECT_SIZEEXPONENT_MIN, objectTileAxisExponent );

        uint objectTilesAxis = pow(2, objectTileAxisExponent) / ATLAS_TILE_SIZE;
		g_ObjectToAtlasProperties[i].desiredAtlasSpace_axis = objectTilesAxis;
        uint objectTilesTotal = objectTilesAxis * objectTilesAxis;
		float4 atlasRect = GetTextureRect(atlas_sliceCount, objectTilesAxis);
		g_ObjectToAtlasProperties[i].atlas_ST = GetUVToAtlasScaleOffset(atlasRect) / g_atlasAxisSize;

		atlas_sliceCount += objectTilesTotal;
	}
	AllMemoryBarrierWithGroupSync();
	// restore order, so the following passes will lookup the correct IDs
	//TODO: the whole thing here is really really really really bad pratice right now
	bool foundMissmatch = true;
	uint iterations = 0; // limit iterations, just in case
	while (foundMissmatch && iterations < MAXIMAL_OBJECTS_PER_VIEW)
	{
		foundMissmatch = false;
		for (uint i = 0; i < g_totalObjectsInView; i++)
		{
			uint usedID = g_ObjectToAtlasProperties[i].objectID;
			if (usedID != i)
			{
				ObjectToAtlasProperties temp = g_ObjectToAtlasProperties[usedID];
				g_ObjectToAtlasProperties[usedID] = g_ObjectToAtlasProperties[i];
				g_ObjectToAtlasProperties[i] = temp;
				foundMissmatch = true;
			}
		}
		iterations++;
	}
}

// copys data to prev buffer, and initalizes 'g_ObjectToAtlasProperties' 
// TODO: can be done with a simple reference swap?!
// -----------------------------------------------------------------------------

#pragma kernel CopyDataToPreFrameBuffer
RWStructuredBuffer<ObjectToAtlasProperties> g_prev_ObjectToAtlasProperties;
[numthreads(SINGLE_ROW_THREAD_SIZE, 1, 1)]
void CopyDataToPreFrameBuffer(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	for (uint i = groupIndex; i < MAXIMAL_OBJECTS_PER_VIEW; i += SINGLE_ROW_THREAD_SIZE)
	{
		g_prev_ObjectToAtlasProperties[i] = g_ObjectToAtlasProperties[i];

		g_ObjectToAtlasProperties[i].objectID = i; // reset object ID
		g_ObjectToAtlasProperties[i].desiredAtlasSpace_axis = 0; //reset the mipmap level, otherwise the max() function for detecting the highest mipmap level would fail overtime
	}
}