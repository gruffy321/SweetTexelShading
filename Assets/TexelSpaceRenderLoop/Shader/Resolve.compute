// Each #kernel tells which function to compile; you can have many kernels
#include "TexelShading.cginc" 
#pragma enable_d3d11_debug_symbols

// common variables
uint g_totalObjectsInView;

// copys data to prev buffer, and initalizes 'g_ObjectToAtlasProperties' 
// TODO: can be done with a simple reference swap?!
// -----------------------------------------------------------------------------

//uint g_objectTriangleOffset[];
RWStructuredBuffer<uint> g_PrimitiveMipMapLevel; //how large is the triangle?
RWStructuredBuffer<uint> g_PrimitiveLocation; //where is the triangle in the atlas located?
RWStructuredBuffer<uint> g_PrimitiveVisibility; //is the triangle visiblie in the view?

StructuredBuffer<uint> g_PrimitiveMipMapLevelRO; //how large is the triangle?
StructuredBuffer<uint> g_PrimitveLocationRO; //where is the triangle in the atlas located?
StructuredBuffer<uint> g_PrimitiveVisibilityRO; //is the triangle visiblie in the view?
#pragma kernel CopyDataToPreFrameBuffer
//RWStructuredBuffer<ObjectToAtlasProperties> g_prev_ObjectToAtlasProperties;
//RWStructuredBuffer<ObjectToAtlasProperties> g_ObjectToAtlasProperties;

[numthreads(SINGLE_ROW_THREAD_SIZE, 1, 1)]
void CopyDataToPreFrameBuffer(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	int index = groupIndex;
    g_PrimitiveMipMapLevel[index] = 0;

	//g_prev_ObjectToAtlasProperties[index] = g_ObjectToAtlasProperties[index];

	//g_ObjectToAtlasProperties[index].objectID = index; // reset object ID
	//g_ObjectToAtlasProperties[index].sizeExponent = 0; //reset the mipmap level, otherwise the max() function for detecting the highest mipmap level would fail overtime
	//g_ObjectToAtlasProperties[index].atlas_ST = 0;
}

// reads the VisibilityBuffer and extracts the visible triangles
// -----------------------------------------------------------------------------
#pragma kernel ExtractCoverage
Texture2D<uint> g_VisibilityBuffer;


uint2 g_VisibilityBuffer_pixelCount;
groupshared uint shared_Object_MipmapLevel[MAXIMAL_OBJECTS_PER_VIEW];
AppendStructuredBuffer<uint> g_ObjectMipMap_append;
[numthreads(COMPUTE_COVERAGE_TILE_SIZE, COMPUTE_COVERAGE_TILE_SIZE,1)]
void ExtractCoverage (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	// initalize shared_Object_MipmapLevel
    for (
        int i = groupIndex; 
        i < MAXIMAL_OBJECTS_PER_VIEW / (COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE); 
        i += COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE)
	{
		shared_Object_MipmapLevel[i] = 0;
	}	
	AllMemoryBarrierWithGroupSync();

	// read pixel from visiblityBuffer
	uint objectID, primitiveID, mipmapLevel;
	uint px;

	px = g_VisibilityBuffer[id.xy];

	DecodeVisibilityBuffer(
		px,
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel);

    if (objectID != 0) // 0 means "undefined"
	{
		// obtain highest mipmap level of object per thread group
		//InterlockedMax(shared_Object_MipmapLevel[objectID], mipmapLevel);

		// "unlock" the triangle for the texel space pass 
		uint baseIndex, subIndex;
		GetVisiblityIDIndicies(objectID, primitiveID, /*out*/ baseIndex, /*out*/ subIndex);
		g_PrimitiveVisibility[baseIndex] = 1;

        mipmapLevel = min(ATLAS_OBJECT_SIZEEXPONENT_MAX, mipmapLevel);
        mipmapLevel = max(ATLAS_OBJECT_SIZEEXPONENT_MIN, mipmapLevel);
        g_PrimitiveMipMapLevel[baseIndex] = mipmapLevel;

    }

	AllMemoryBarrierWithGroupSync();
	for (int j = 0; j < MAXIMAL_OBJECTS_PER_VIEW / (COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE); j++)
	{
		int index = groupIndex + j * COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE;
		if (shared_Object_MipmapLevel[index] != 0)
		{
			// pass highest mipmap level per thread gorup to append buffer for futher processing
			//uint packedValue = EncodeVisibilityBuffer(index, primitiveID, shared_Object_MipmapLevel[index]);
			//g_ObjectMipMap_append.Append(packedValue);
		}
	}

}

#pragma kernel MipMapMeltDown
ConsumeStructuredBuffer<uint> g_ObjectMipMap_consume;
[numthreads(COMPUTE_COVERAGE_TILE_SIZE, COMPUTE_COVERAGE_TILE_SIZE, 1)]
void MipMapMeltDown(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	// initalize shared_Object_MipmapLevel
	for (int i = 0; i < MAXIMAL_OBJECTS_PER_VIEW / (COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE); i++)
	{
		shared_Object_MipmapLevel[i + groupIndex * COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE] = 0;
	}

	AllMemoryBarrierWithGroupSync();
	uint objectID, primitiveID, mipmapLevel;
	
	DecodeVisibilityBuffer(
		1,
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel);

	// obtain highest mipmap level of object per thread group
	InterlockedMax(shared_Object_MipmapLevel[objectID], mipmapLevel);

	// store data
	for (int j = 0; j < MAXIMAL_OBJECTS_PER_VIEW / (COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE); j++)
	{
		int index = j + groupIndex * COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE;
		g_ObjectMipMap_append.Append(shared_Object_MipmapLevel[index]);
	}
}

#pragma kernel MipMapFinalize

Buffer<int> g_ObjectMipMapCounterValue;
[numthreads(COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE, 1, 1)]
void MipMapFinalize(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	// initalize shared_Object_MipmapLevel
	for (int i = 0; i < MAXIMAL_OBJECTS_PER_VIEW / (COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE); i++)
	{
		shared_Object_MipmapLevel[groupIndex + i * COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE] = 0;
	}

	AllMemoryBarrierWithGroupSync();
	for (int j = 0; j < g_ObjectMipMapCounterValue[0]; j += COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE)
	{
		uint objectID, primitiveID, mipmapLevel;

		DecodeVisibilityBuffer(
			g_ObjectMipMap_consume.Consume(),
			/*out*/ objectID,
			/*out*/ primitiveID,
			/*out*/ mipmapLevel);

		// obtain highest mipmap level of object per thread group
		InterlockedMax(shared_Object_MipmapLevel[objectID], mipmapLevel);
	}
	
	AllMemoryBarrierWithGroupSync();
	// store data
	for (int k = 0; k < MAXIMAL_OBJECTS_PER_VIEW / (COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE); k++)
	{
		int index = groupIndex + k * COMPUTE_COVERAGE_TILE_SIZE * COMPUTE_COVERAGE_TILE_SIZE;
		//g_ObjectToAtlasProperties[index].sizeExponent = (shared_Object_MipmapLevel[index]);
	}
}

// provides debug information
// -----------------------------------------------------------------------------
#pragma kernel DebugShowVertexID
RWTexture2D<float4> g_DebugTexture;
StructuredBuffer<ObjectToAtlasProperties> g_ObjectToAtlasPropertiesR;
int g_DebugPassID;

[numthreads(BLOCK_THREAD_SIZE, BLOCK_THREAD_SIZE,1)]
void DebugShowVertexID (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	uint objectID, primitiveID, mipmapLevel;
	DecodeVisibilityBuffer(
		g_VisibilityBuffer[id.xy],
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel); 


	uint baseIndex, subIndex;
	GetVisiblityIDIndicies(objectID, primitiveID, /*out*/ baseIndex, /*out*/ subIndex);

	half4 output = 0;
	float f;
	switch (g_DebugPassID)
	{
		case 1:
			f = objectID;// floor(primitiveID / PRIMITIVE_CLUSTER_SIZE);
			output = half4(sin(f), sin(f / 2), sin(f / 4), 0) * 0.5 + 0.5;
			break;
		case 2:
			f = floor(primitiveID / PRIMITIVE_CLUSTER_SIZE);
			output = half4(sin(f), sin(f / 63.0), sin(f / 511.0), 0) * 0.5 + 0.5;
			break;
		case 3:
            float mipmap_f = g_PrimitiveMipMapLevel[baseIndex] / 13.0;
			output = mipmap_f;
			break;
		case 4:
			output = mipmapLevel / 13.0;
			break;
	}

	g_DebugTexture[id.xy] = output;
	
}

// packs texel atlas
// -----------------------------------------------------------------------------


#pragma kernel AtlasPacking

groupshared uint shared_atlasIndex;
uint g_totalTriangles;
[numthreads(SINGLE_ROW_THREAD_SIZE, 1, 1)]
void AtlasPacking(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	if (groupIndex == 0)
	{
        shared_atlasIndex = 0;
    }
	AllMemoryBarrierWithGroupSync();

    for (uint j = ATLAS_OBJECT_SIZEEXPONENT_MAX; ATLAS_OBJECT_SIZEEXPONENT_MIN <= j; j--)
    {
        for (uint i = groupIndex + MAX_PRIMITIVES_PER_OBJECT; i < g_totalTriangles + MAX_PRIMITIVES_PER_OBJECT; i += SINGLE_ROW_THREAD_SIZE)
        {
            if (g_PrimitiveVisibility[i] == 0)
                continue;

			// TODO: can't use clamp() somehow...
			// TODO: do this in PS or somewhere earlier?
			// clamp atlasExponent to [ATLAS_OBJECT_SIZEEXPONENT_MIN, ATLAS_OBJECT_SIZEEXPONENT_MAX]
            uint primitiveMipMapLevel = g_PrimitiveMipMapLevel[i];
            //primitiveMipMapLevel = min(ATLAS_OBJECT_SIZEEXPONENT_MAX, primitiveMipMapLevel);
            //primitiveMipMapLevel = max(ATLAS_OBJECT_SIZEEXPONENT_MIN, primitiveMipMapLevel);
			
            if (primitiveMipMapLevel == j)
            {
				// calculate triangle size in atlas units
                uint primitiveTexelAxisLength = pow(2, primitiveMipMapLevel);

                uint primitiveTexelArea = primitiveTexelAxisLength * primitiveTexelAxisLength;
		
				//float4 atlasRect = GetTextureRect(gshared_atlasIndex, objectTilesAxis);
				//g_ObjectToAtlasProperties[i].atlas_ST = GetUVToAtlasScaleOffset(atlasRect) / (float)g_atlasAxisSize;
                InterlockedAdd(shared_atlasIndex, primitiveTexelArea, g_PrimitiveLocation[i]); //TODO: should be possible w/o atomics
            }
        }
    }
}



#pragma kernel GetPixels
[numthreads(SINGLE_ROW_THREAD_SIZE, 1, 1)]
void GetPixels(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{

}