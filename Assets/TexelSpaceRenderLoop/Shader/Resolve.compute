// Each #kernel tells which function to compile; you can have many kernels
#include "TexelShading.cginc" 
#pragma enable_d3d11_debug_symbols

// common variables
uint g_totalObjectsInView;

#pragma kernel ExtractCoverage
Texture2D<int> g_ScreenVertexID;
RWBuffer<uint> g_VertexIDVisiblity;
RWStructuredBuffer<ObjectToAtlasProperties> g_ObjectToAtlasProperties;
uint gshared_object_mipmap[MAXIMAL_OBJECTS_PER_VIEW];
 
[numthreads(COMPUTE_COVERAGE_TILE_SIZE, COMPUTE_COVERAGE_TILE_SIZE,1)]
void ExtractCoverage (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	uint objectID, primitiveID, mipmapLevel;
	DecodeVisibilityBuffer(
		g_ScreenVertexID[id.xy],
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel); 

	uint baseIndex, subIndex;
	GetVisiblityIDIndicies(objectID, primitiveID, /*out*/ baseIndex, /*out*/ subIndex);
	g_VertexIDVisiblity[baseIndex] = 1;

	//g_VertexIDVisiblity[EncodeVisibilityBuffer(objectID, primitiveID, 0)] = 1; //unlock primitve
}


StructuredBuffer<ObjectToAtlasProperties> g_ObjectToAtlasPropertiesR;
#pragma kernel DebugShowVertexID
RWTexture2D<float4> g_DebugTexture;
[numthreads(BLOCK_THREAD_SIZE, BLOCK_THREAD_SIZE,1)]
void DebugShowVertexID (uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	uint objectID, primitiveID, mipmapLevel;
	DecodeVisibilityBuffer(
		g_ScreenVertexID[id.xy],
		/*out*/ objectID,
		/*out*/ primitiveID,
		/*out*/ mipmapLevel); 

	//float mipmap_f = g_ObjectToAtlasPropertiesR[objectID].desiredAtlasSpace_axis / 13.0;

	uint baseIndex, subIndex;
	GetVisiblityIDIndicies(objectID, primitiveID, /*out*/ baseIndex, /*out*/ subIndex);

	float visiblity = (float) g_VertexIDVisiblity[baseIndex];

	g_DebugTexture[id.xy] = visiblity;// half4(sin(floor(primitiveID / 16.0)), sin(0), sin(0), 0) * 0.5 + 0.5;
	
}


// I use morton-code / z-shape for atlas packing
// this makes the packing very much straight forward and the complexity for insertion is always O(1).
// But this only works, as long as the textures sizes are power-of-two (256, 512, 1024,...) and the largest textures are getting inserted first
uint2 GetTilePosition(uint index)
{
    return uint2(DecodeMorton2X(index), DecodeMorton2Y(index));
}

float4 GetTextureRect(uint index, uint tilesPerAxis)
{
	float2 atlasPosition_tileSpace = GetTilePosition(index);
    float2 min = atlasPosition_tileSpace * ATLAS_TILE_SIZE;
    float2 max = min + tilesPerAxis * ATLAS_TILE_SIZE;

	return float4(min, max);
}

float4 GetUVToAtlasScaleOffset(float4 atlasPixelSpace)
{
    return float4(atlasPixelSpace.zw - atlasPixelSpace.xy, atlasPixelSpace.xy);
}


#pragma kernel AtlasPacking
uint atlas_sliceCount;
uint g_atlasAxisSize;
[numthreads(1,1,1)] 
void AtlasPacking(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	// sort atlas objects by size (largest-smallest) so it fits the condition for a morton code packing

	//TODO: use multithread radix sort
	//simple bubble sort...
	for (uint write = 0; write < g_totalObjectsInView; write++)
	{
		for (uint sort = 0; sort < g_totalObjectsInView - 1 ; sort++)
		{
			// check if next object is larger than current
			if (g_ObjectToAtlasProperties[sort].desiredAtlasSpace_axis < 
				g_ObjectToAtlasProperties[sort + 1].desiredAtlasSpace_axis)
			{		
				// swap next object with curent
				ObjectToAtlasProperties temp = g_ObjectToAtlasProperties[sort + 1];				
				g_ObjectToAtlasProperties[sort + 1] = g_ObjectToAtlasProperties[sort];
				g_ObjectToAtlasProperties[sort] = temp;
			}
		}
	}

	AllMemoryBarrierWithGroupSync();
	//TODO: muttihreading can't be used here, since the order of exectuion is crucial...
	for(uint i = 0; i < g_totalObjectsInView; i++)
	{
		// TODO: can't use clamp() somehow...
		uint objectTileAxisExponent = min(ATLAS_OBJECT_SIZEEXPONENT_MAX, g_ObjectToAtlasProperties[i].desiredAtlasSpace_axis);
		objectTileAxisExponent = max(ATLAS_OBJECT_SIZEEXPONENT_MIN, objectTileAxisExponent );

        uint objectTilesAxis = pow(2, objectTileAxisExponent) / ATLAS_TILE_SIZE;
		g_ObjectToAtlasProperties[i].desiredAtlasSpace_axis = objectTilesAxis;
        uint objectTilesTotal = objectTilesAxis * objectTilesAxis;
		float4 atlasRect = GetTextureRect(atlas_sliceCount, objectTilesAxis);
		g_ObjectToAtlasProperties[i].atlas_ST = GetUVToAtlasScaleOffset(atlasRect) / g_atlasAxisSize;

		atlas_sliceCount += objectTilesTotal;
	}
	AllMemoryBarrierWithGroupSync();
	// restore order, so the following passes will lookup the correct IDs
	//TODO: the whole thing here is really really really really bad pratice right now
	bool foundMissmatch = true;
	uint iterations = 0; // limit iterations, just in case
	while (foundMissmatch && iterations < MAXIMAL_OBJECTS_PER_VIEW)
	{
		foundMissmatch = false;
		for (uint i = 0; i < g_totalObjectsInView; i++)
		{
			uint usedID = g_ObjectToAtlasProperties[i].objectID;
			if (usedID != i)
			{
				ObjectToAtlasProperties temp = g_ObjectToAtlasProperties[usedID];
				g_ObjectToAtlasProperties[usedID] = g_ObjectToAtlasProperties[i];
				g_ObjectToAtlasProperties[i] = temp;
				foundMissmatch = true;
			}
		}
		iterations++;
	}
}


#pragma kernel CopyDataToPreFrameBuffer
RWStructuredBuffer<ObjectToAtlasProperties> g_prev_ObjectToAtlasProperties;
[numthreads(SINGLE_ROW_THREAD_SIZE, 1, 1)]
void CopyDataToPreFrameBuffer(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	for (uint i = groupIndex; i < MAXIMAL_OBJECTS_PER_VIEW; i += SINGLE_ROW_THREAD_SIZE)
	{
		g_prev_ObjectToAtlasProperties[i] = g_ObjectToAtlasProperties[i];

		g_ObjectToAtlasProperties[i].objectID = i; // reset object ID
		g_ObjectToAtlasProperties[i].desiredAtlasSpace_axis = 0; //reset the mipmap level, otherwise the max() function for detecting the highest mipmap level would fail overtime
	}
}